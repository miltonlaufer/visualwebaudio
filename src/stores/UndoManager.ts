import {
  types,
  IJsonPatch,
  IAnyStateTreeNode,
  recordPatches,
  IPatchRecorder,
  createActionTrackingMiddleware2,
  getEnv,
  getRoot,
  applyPatch,
  flow,
  addMiddleware,
  addDisposer,
  decorate,
  isActionContextThisOrChildOf,
} from 'mobx-state-tree'
import { atomic } from './index'

const Entry = types.model('UndoManagerEntry', {
  patches: types.frozen<ReadonlyArray<IJsonPatch>>(),
  inversePatches: types.frozen<ReadonlyArray<IJsonPatch>>(),
})

const UndoManager = types
  .model('UndoManager', {
    history: types.array(Entry),
    undoIdx: 0,
  })
  .views(self => ({
    get undoLevels() {
      return self.undoIdx
    },
    get redoLevels() {
      return self.history.length - self.undoIdx
    },
    get canUndo() {
      return this.undoLevels > 0
    },
    get canRedo() {
      return this.redoLevels > 0
    },
  }))
  .actions(self => {
    let includeHooks = false
    let targetStore: IAnyStateTreeNode
    let recordingDisabled = 0

    interface Context {
      recorder: IPatchRecorder
    }

    type GroupRecorder = Pick<IPatchRecorder, 'patches' | 'inversePatches'>
    const groupRecorders: GroupRecorder[] = []

    const undoRedoMiddleware = createActionTrackingMiddleware2<Context>({
      filter(call) {
        if (call.env) {
          // already recording
          return false
        }
        if (call.context === self) {
          // also skip actions over self
          return false
        }

        // Skip only essential system actions that should never be recorded
        const excludedActions = [
          'undo', // Undo operations should not record themselves
          'redo', // Redo operations should not record themselves
          '@APPLY_PATCHES', // MST internal patch application - should not be recorded
          'setIsPlaying', // Play/stop state changes should not be recorded
          'selectNode', // Node selection changes should not be recorded
          'setProjectModified', // Project modification flag changes should not be recorded
          'markProjectModified', // Project modification flag changes should not be recorded
        ]

        if (excludedActions.includes(call.name)) {
          return false
        }

        return true
      },
      onStart(call) {
        const recorder = recordPatches(call.tree, (patch, _inversePatch, actionContext) => {
          if (recordingDisabled) {
            return false
          }

          // Filter out patches to system properties that shouldn't be recorded in undo history
          if (
            patch.path.endsWith('/isProjectModified') ||
            patch.path.endsWith('/isUndoRedoInProgress') ||
            patch.path.endsWith('/propertyChangeCounter') ||
            patch.path.endsWith('/graphChangeCounter') ||
            patch.path.endsWith('/nodeStateChangeCounter')
          ) {
            return false
          }

          // only record patches that were generated by this action or children of this action
          return !!actionContext && isActionContextThisOrChildOf(actionContext, call.id)
        })
        recorder.resume()
        call.env = {
          recorder,
        }
      },
      onFinish(call, error) {
        const recorder = call.env!.recorder
        recorder.stop()
        if (error === undefined) {
          // if no errors from the action, we can safely clean up call.env before proceeding further
          call.env = undefined
          if (groupRecorders.length > 0) {
            const groupRecorder = groupRecorders[groupRecorders.length - 1]
            groupRecorder.patches = groupRecorder.patches.concat(recorder.patches)
            groupRecorder.inversePatches = groupRecorder.inversePatches.concat(
              recorder.inversePatches
            )
          } else {
            ;(self as any).addUndoState(recorder)
          }
        } else {
          // if there was an error, we need call.env to filtered action from `recorder.undo -> applyPatch`, so we clean up call.env afterwards
          recorder.undo()
          call.env = undefined
        }
      },
    })

    const skipRecording = <T>(fn: () => T): T => {
      recordingDisabled++
      try {
        return fn()
      } finally {
        recordingDisabled--
      }
    }

    return {
      addUndoState(recorder: GroupRecorder) {
        this.withoutUndo(() => {
          if (recorder.patches.length === 0) {
            // skip recording if patches is empty
            return
          }
          self.history.splice(self.undoIdx)
          self.history.push({
            patches: recorder.patches,
            inversePatches: recorder.inversePatches,
          })
          let maxLength = Infinity
          try {
            maxLength = getEnv(self).maxHistoryLength || Infinity
          } catch {
            // No environment or maxHistoryLength not set, use default
            maxLength = Infinity
          }
          self.history.splice(0, self.history.length - maxLength)
          self.undoIdx = self.history.length
        })
      },
      afterCreate() {
        const selfRoot = getRoot(self)

        // Try to get targetStore from environment, fallback to root if environment doesn't exist
        let envTargetStore: IAnyStateTreeNode | undefined
        let envIncludeHooks: boolean | undefined

        try {
          const env = getEnv(self)
          envTargetStore = env.targetStore
          envIncludeHooks = env.includeHooks
        } catch {
          // No environment set up, use defaults
          envTargetStore = undefined
          envIncludeHooks = undefined
        }

        targetStore = envTargetStore || selfRoot
        if (targetStore === self) {
          throw new Error(
            "UndoManager should be created as part of a tree, or with `targetStore` in it's environment"
          )
        }

        if (typeof envIncludeHooks === 'boolean') {
          includeHooks = envIncludeHooks
        }

        addDisposer(self, addMiddleware(targetStore, undoRedoMiddleware, includeHooks))
      },
      undo: decorate(atomic, () => {
        skipRecording(() => {
          if (!self.canUndo) {
            throw new Error('undo not possible, nothing to undo')
          }
          applyPatch(
            getRoot(targetStore),
            // n.b: reverse patches back to forth
            self.history[self.undoIdx - 1].inversePatches.slice().reverse()
          )
          self.undoIdx--
        })
      }),
      redo: decorate(atomic, () => {
        skipRecording(() => {
          if (!self.canRedo) {
            throw new Error('redo not possible, nothing to redo')
          }
          applyPatch(getRoot(targetStore), self.history[self.undoIdx].patches)
          self.undoIdx++
        })
      }),
      withoutUndo<T>(fn: () => T): T {
        return skipRecording(fn)
      },
      withoutUndoFlow(generatorFn: () => any) {
        return flow(function* __withoutUndoFlow__() {
          recordingDisabled++
          try {
            return yield* generatorFn()
          } finally {
            recordingDisabled--
          }
        })
      },
      startGroup<T>(fn: () => T): T {
        if (groupRecorders.length >= 1) {
          throw new Error(
            'a previous startGroup is still running, did you forget to call stopGroup?'
          )
        }
        groupRecorders.push({
          patches: [],
          inversePatches: [],
        })
        return fn()
      },
      stopGroup() {
        const groupRecorder = groupRecorders.pop()
        if (!groupRecorder) {
          throw new Error(
            'each call to stopGroup requires a previous call to startGroup, did you forget to call startGroup?'
          )
        }
        this.addUndoState(groupRecorder)
      },
      clear: decorate(atomic, () => {
        skipRecording(() => {
          self.history.clear()
          self.undoIdx = 0
        })
      }),
      clearUndo: decorate(atomic, () => {
        skipRecording(() => {
          self.history.splice(0, self.undoLevels)
          self.undoIdx = 0
        })
      }),
      clearRedo: decorate(atomic, () => {
        skipRecording(() => {
          self.history.splice(self.undoIdx, self.redoLevels)
        })
      }),
    }
  })

export default UndoManager
